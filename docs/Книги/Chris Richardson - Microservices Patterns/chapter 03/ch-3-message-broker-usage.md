---
share: true
tags: 
 - microservice/messaging
 - message-broker
---
# Использование брокера сообщений
Приложения, основанные на сообщениях, обычно применяют *брокер сообщений* - инфраструктурный компонент, через который сервисы общаются друг с другом. Однако, архитектура обмена сообщений может и не иметь брокера, и сервисы взаимодействуют напрямую.
## Обмен сообщениями без брокера
В архитектуре без брокера сервисы общаются напрямую. Одна из реализаций такого подхода - проект [ZeroMQ](https://zeromq.org/)
### Преимущества прямого обмена
+ Более легковесный сетевой трафик и меньше задержки (нет оверхеда брокера).
+ Брокер не станет узким местом или единой точкой отказа.
+ Более простое администрирование, так как не нужно администрировать брокер.
### Недостатки прямого обмена
- Сервисы должны знать о местоположении друг друга, следовательно, надо использовать [[ch-3-service-discovery|механизмы обнаружения сервисов]].
- Снижена степень доступности, так как отправитель и получатель должны быть доступны на время передачи сообщения.
- Дополнительные трудности в реализации таких механизмов как гарантированная доставка.
## Обмен сообщениями на основе брокера
Брокер - это промежуточное звено, через которое проходят все сообщения. Отправитель передает сообщение брокеру, а тот доставляет его получателю. Преимущество в том, что отправителю не нужно знать адрес потребителя. Кроме того, брокер может буферизовать сообщения, пока у получателя не появится возможность их обработать.
Примеры брокеров:
- [ActiveMQ](http://activemq.apache.org/)
- [RabbitMQ](https://www.rabbitmq.com/)
- [Apache Kafka](http://kafka.apache.org/)
- [AWS Kinesis](https://aws.amazon.com/ru/kinesis/) (облачный)
- [AWS SQS](https://aws.amazon.com/ru/sqs/) (облачный)

## Факторы, которые надо учитывать при выборе брокера
- *Поддерживаемые языки программирования*. Больше - лучше. Ну или нужен тот, на котором мы пишем.
- *Поддерживаемые стандарты обмена сообщениями*. Поддерживаются ли стандарты вроде **AMQP** или **STOMP**? Используется ли закрытый протокол?
- *Порядок следования сообщений*. Сохраняет ли брокер порядок следования сообщений?
- *Гарантии доставки*. Какие гарантии доставки даёт брокер?
- *Постоянное хранение*. Сохраняются ли сообщения на диск? Могут ли сообщения пережить сбой брокера?
- *Устойчивость*. Если потребитель переподключится к брокеру, получит ли он сообщения, отправленные, пока он был отключён?
- *Масштабируемость*.
- *Конкурирующие потребители*. Поддерживает ли брокер сообщений конкурирующих потребителей?

У каждого брокера свои плюсы и минусы. Высокая латентность - плата за надёжную доставку и хранение на диске. Низкая латентность может достигаться за счёт отсутствия порядка и хранения только в памяти.

## Реализация каналов сообщений с помщью брокера
|Брокер сообщений|[Канал типа "точка-точка"](point-to-point-channel)|[Канал типа "издатель-подписчик"](publish-subscribe-channel)|
|---|---|---|
|JMS|Очередь|Тема|
|Apache Kafka|Тема(топик, topic)|Тема|
|Брокеры на основе AMQP, такие как RabbitMQ|Обмен+Очередь|Обмен типа fanout и отдельная очередь для каждого потребителя|
|AWS Kinesis|Поток|Поток|
|AWS SQS|Очередь|-|

## Преимущества обмена сообщениями через брокера
+ *Слабая связанность*. Для выполнения запроса клиенту нужно знать только канал и адрес брокера.
+ *Буферизация сообщений*. Брокер буферизирует сообщения до тех пор, пока их не смогут обработать.
+ *Гибкое взаимодействие*. Обмен сообщениями поддерживает все описанные стили.
+ *Явное межпроцессное взаимодействие*. В отличие от RPC, обмен сообщениями не выглядит как вызов процедуры.

## Недостатки обмена сообщениями на основе брокера
- *Потенциальное узкое место производительности*.
- *Потенциальная единая точка отказа*.
- *Дополнительная сложность в администрировании*.
