---
share: true
tags: 
 - microservice/transaction
 - microservice/saga
---
# Управление транзакциями в микросервисной архитектуре
Почти любой запрос, обрабатываемый промышленным приложением, выполняется в рамках транзакции базы данных. Существует императивный (а некоторые фреймворки предоставляют декларативный) API для выполнения кода в рамках транзакции. Таким образом, в монолитных приложениях с единой БД просто управлять транзакциями. Однако, если приложение использует несколько БД и брокеров сообщений, процесс затрудняется. А в микросервисной архитектуре транзакции охватывают несколько сервисов, каждый из которых имеет свою БД.
## Микросервисная архитектура и необходимость в распределенных транзакциях.
![[Pasted image 20210918164324.png]]
Представим, что есть некая системная операция `createOrder()`. В рамках этой операции нужно
 - убедиться в том, что заказчик имеет право размещать заказы;
 - проверить детали заказа;
 - авторизовать банковскую карту заказчика;
 - Создать запись Order в БД.
 
При этом данные должны быть согласованы.
## Проблемы с распределенными транзакциями
Традиционный подход к обеспечению согласованности данных заключается в применении распределенных транзакций. Стандартом де-факто здесь является [X/Open XA](https://ru.wikipedia.org/wiki/XA). Модель XA использует *двухэтапную фиксацию* (two-phase commit, 2PC), чтобы гарантировать сохранение или откат всех изменений в транзакции. Для этого требуется, чтобы БД, брокеры сообщений, драйверы БД и API обмена сообщениями соответствовали стандарту XA, необходим также механизм IPC, который распространяет глобальные идентификаторы XA-транзакций. С XA совместимы большинство реляционных БД, некоторые брокеры.
Однако, многие современные продукты, такие как MongoDB, Cassandra, RabbitMQ и Apache Kafka, не поддерживают распределенные транзакции.
Также есть проблема в том, что XA-транзакции есть разновидность синхронного IPC - чтобы зафиксировать транзакцию, должны быть доступны все вовлеченные в нее сервисы.
Следуя [[cap-theorem|CAP-теореме]], в наши дни принято жертвовать согласованностью в пользу доступности.
## Использование шаблона "повествование" для сохранения согласованности данных.
Рассмотрим [[saga-pattern|шаблон "повествование"]]. Повествования имеют несколько важных отличий от ACID-транзакций. Прежде всего им не хватает изолированности. Во-вторых, так как каждая локальная транзакция фиксирует свои изменения, для отката необходимо использовать компенсирующие транзакции.
