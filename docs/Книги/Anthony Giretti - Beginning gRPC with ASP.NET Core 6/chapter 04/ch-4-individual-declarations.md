---
share: true
tags:
 - protobuf/declarations
---
# Единичные декларации
**Всегда** требуется указывать версию синтаксиса. Варианты:
- `Proto3`
- `Proto2`
- `Proto1` (устаревший)

Здесь и далее мы будем использовать третью версию. Несмотря на то, что версия 2 (`proto2`) не является устаревшей, рекомендуется использовать третью версию. К примеру, в версии 3 есть такие фичи как кодировка JSON, *известные типы* или принудительное использование UTF-8.
Итак, файл protobuf начинается с определения версии синтакиса:
```protobuf
syntax = "proto3";
```
Язык позволяет задавать пространства имён (namespaces) для сервисов и сообщений при помощи ключевого слова `package` (пакет). В следующем примере имя пакета будет `gRPCDemo.v1`. 
```protobuf
syntax = "proto3";
package gRPCDemo.v1;
```
При генерации кода C\# из файла .proto, имя пакета станет именем пространства имён для сгенерированных классов.
Так как указание имени пакета необязательно, при его отсутствии код будет добавлен в пространство имён `global`, так что обращаться к сгенерированным сервисам нужно будет так:
```csharp
var instance = new global::SomeService();
```
Однако автор *не рекомендует* использование `global`, и настоятельно советует задавать имя неймспейса через имя пакета, или через опцию `csharp_namespace`:
```protobuf
syntax = "proto3";
package gRPCDemo.v1;
option csharp_namespace = "CountryService.Web.gRPC";
```
Теперь неймспейс в сгенерированном коде будет называться `CountryService.Web.gRPC`. Тогда зачем нужно имя пакета? Имя пакета будет использовано для того, чтобы задать название сгенерированному сервису, а это имя будет использовано для *генерации URL*, используемого для вызова удалённой процедуры. %% добавить ссылку на главу 6 %%
Кроме опции `csharp_namespace` существуют и другие, их можно посмотреть [здесь](https://protobuf.dev/programming-guides/proto3/#options).