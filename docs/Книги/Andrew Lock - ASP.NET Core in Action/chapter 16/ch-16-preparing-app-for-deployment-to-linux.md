---
share: true
tags:
 - NET/ASPNETCore/publish
 - Linux
---
# Подготовка приложения к развертыванию в Linux
Когда запрос поступает на [[reverse-proxy|обратный прокси-сервер]], он содержит некую информацию, которая теряется после перенаправления к приложению. Например, исходный запрос идёт от IP-адреса клиента, а после пересылки - от IP-адреса обратного прокси. Или, если обратный прокси-сервер используется для [[ch-18-ssl-offloading-and-related|SSL-терминирования]], то запрос с использованием HTTPS может поступать к приложению в виде HTTP-запроса.
Стандартным решением этих проблем может выступать добавление к запросу дополнительных заголовков перед пересылкой в приложение. Например, `X-Forwarded-For` с исходным IP-адресом клиента или `X-Forwarded-Proto` с исходной схемой запроса (http или https).
Чтобы приложение работало правильно, оно должно искать и обрабатывать такие заголовки во входящих запросах.
Чтобы добиться этого, можно использовать компонент `ForwardedHeadersMiddleware`. Если используется метод по умолчанию - `Host.CreateDefaultBuilder()`, этот компонент уже добавлен в отключённом состоянии. Чтобы активировать его, нужно установить переменную окружения `ASPNETCORE_FORWARDEDHEADERS_ENABLED` в `true`.
Также можно, если метод по умолчанию не используется, добавить компонент в начало конвейера самостоятельно и сконфигурировать его, указав заголовки, которые нужно искать:
```csharp
public class Startup
{
	public void Configure(IApplicationBuilder app)
	{
		app.UseForwardedHeaders(new ForwardedHeadersOptions
		{
			ForwardedHeaders = 
				ForwardedHeaders.XForwardedFor |
				ForwardedHeaders.XForwardedProto
		});
		
		app.UseHttpsRedirection();
		app.UseRouting();
		app.UseAuthentication();
		app.UseMvc();
	}
}
```
> [!warning] Предупреждение
> Важно, чтобы компонент `ForwardedHeadersMiddleware` был размещен в начале конвейера перед выполнением любого компонента, зависящего от схемы.

Помимо перенаправленных заголовков, нужно учитывать еще несколько моментов при развертывании в Linux:
- *окончание строк* - в Linux и Windows используются разные символы конца строки (`LF` в Linux, сочетание `CRLF` - в Windows);
- *разделитель каталогов пути* в Linux используется `/`, в Windows - `\`. Поэтому для конструирования пути в коде следует использовать метод `Path.Combine`, а не символ-разделитель напрямую;
- *переменные окружения не могут содержать символ `:`* - как было показано [[ch-11-adding-configuration-provider-in-program-cs|ранее]],  этот символ используется для обозначения различных разделов конфигурации, поэтому его часто необходимо использовать в переменных окружения. Чтобы решить эту проблему, нужно использовать сдвоенное подчёркивание (`__`), которое будет интерпретироваться ASP.NET Core также, как `:`;
- *данные о часовом поясе и данные локализации могут отсутствовать* - для этого нужно установить данные часового пояса с помощью менеджера пакетов дистрибутива[^1];
- *разная структура каталогов* - необходимо помнить об этом, если в коде приложения жёстко зашиты какие-либо пути.


[^1]: О том, как автор решил эту проблему, он написал [пост в своём блоге](https://andrewlock.net/dotnet-core-docker-and-cultures-solving-culture-issues-porting-a-net-core-app-from-windows-to-linux/)