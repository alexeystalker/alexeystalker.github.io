---
share: true
tags:
 - NET/ASPNETCore/middleware
---
# Ветвление конвейера с помощью метода расширения Map
Метод расширения `Map()` позволяет организовать конвейер промежуточного ПО в ветвящуюся структуру; выбор ветви при этом зависит от URL запроса.
![[Pasted image 20220906105557.png]]
> [!Note] Примечание
> Сопоставление URL-адресов в методе `Map()` концептуально аналогично маршрутизации, но гораздо проще и со множеством ограничений. Например, используется простое сопоставление префиксов, и нельзя использовать параметры маршрута. Как правило, следует отдавать предпочтение созданию [[endpoint|конечных точек]], а не ветвлению с использованием `Map()`

Например, предположим, что мы хотим создать простую конечную точку проверки работоспособности при помощи [[ch-19-simple-endpoints-with-run-extension|метода]] `Run()`. Однако, мы хотим, чтобы проверка работоспособности выполнялась только по запросу на URL-адрес `/ping`, а все остальные запросы работали при помощи Razor Pages[^1].

Добавим ветвь конвейера с помощью метода расширения `Map()`:
```csharp
public void Configure(IApplicationBuilder app)
{
	app.UseDeveloperExceptionPage();
	
	app.Map("/ping", (IApplicationBuilder branch) =>
	{
		branch.UseExceptionHandler();
		branch.Run(async (HttpContext context) =>
		{
			context.Response.ContentType = "text/plain";
			await context.Response.WriteAsync("pong");
		});
	});
	
	app.UseStaticFiles();
	app.UseRouting();
	app.UseEndpoints(endpoints => endpoints.MapRazorPages());
}
```
В этом примере все запросы, начинающиеся с `/ping`, будут проходить по ветви, определенной для билдера `branch`: например, `/ping`, `/ping/go` или `/ping?id=123`, а значит, будут возвращать простой ответ `"pong"`.

При необходимости вызовы `Map()` можно вкладывать друг в друга, чтобы делать более сложное ветвление конвейера. Однако для сложных сценариев лучше использовать [[ch-19-creating-custom-endpoints-with-endpoint-routing|механизм маршрутизации конечных точек]].

Одной из ситуаций, когда метод `Map()` может быть полезен — необходимость получить два "независимых" более мелких приложения, но развёртываемых одновременно. Однако в этом случае приложения будут иметь общие конфигурацию и [[di-container|контейнер внедрения зависимостей]][^2].

Последний момент, о котором необходимо помнить — то, что метод `Map()` изменяет свойство `Path`, которое видит промежуточное ПО в ветви. Сегменты, совпадающие с префиксом ветви, отсекаются и перемещаются в свойство `PathBase`. 
![[Pasted image 20220906113337.png]]
Свойство `PathBase` может использоваться, например, [[ch-5-generating-urls-from-route-parameters|генератором ссылок]] для генерации правильных адресов.

[^1]: Сценарий с проверкой работоспособности взят для демонстрации. В реальности следует использовать встроенную в ASP.NET Core проверку работоспособности. [Подробнее](https://docs.microsoft.com/ru-ru/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-5.0)
[^2]: О создании _по-настоящему_ независимых ветвей см. [здесь](https://www.strathweb.com/2017/04/running-multiple-independent-asp-net-core-pipelines-side-by-side-in-the-same-application/)