---
share: true
tags:
 - NET/Razor
---
# Создание представлений Razor
В ASP.NET Core всякий раз, когда нужно вернуть ответ в виде HTML, нужно использовать представление для генерации ответа. Конечно, есть исключительные ситуации, когда можно генерировать HTML без использования представления, но страниы Razor и контроллеры MVC всегда должны использовать представления.
Рассмотрим, какие возможности доступны при использовании представлений Razor.
## Представления Razor и сопутствующий код
Страница Razor боычно состоит из двух файлов:
- файла .cshtml, который обычно называют представлением Razor
- файла .cshtml.cs, который обычно называют *сопутствующим кодом*. Он содержит `PageModel`.

Представление Razor содержит [[razor-directive|директиву]] `@page`, которая делает его страницей Razor. Без нее платформа Razor Pages не будет маршрутизировать запросы на страницу.
Далее идёт директива `@model` с типом модели страницы, например
```razor
@page
@model ToDoItemModel
```
Как только запрос маршрутизируется на страницу Razor, фреймворк ищет директиву `@model`, чтобы решить, какую модель использовать, и [[ch-6-binding-model|осуществляет]] [[model-binding|привязку]] к свойствам, помеченным `[BindProperty]`, затем выполняет соответствующий обработчик страницы. Если директиву `@model` не указать, выполнится [[ch-5-selecting-page-handler|обработчик по умолчанию]].
## Знакомство с шаблонами Razor
Шаблоны представлений Razor — смесь C\# и HTML, что позволяет как описать, что именно отправлять в браузер, так и динамически изменять то, что визуализируется.
Например, визуализируем список строк с задачами.
```razor
@page
@{
	var tasks = new List<string>{ "buy milk", "Buy eggs", "buy bread" };
}
<h1>Tasks to complete</h1>
<ul>
	@for(var i=0; i < tasks.Count; i++)
	{
		var task = tasks[i];
		<li>@i - @task</li>
	}
</ul>
```
При визуализации получим следующий код:
```html
<h1>Tasks to complete</h1>
<ul>
	<li>0 - Buy milk</li>
	<li>1 - Buy eggs</li>
	<li>2 - Buy bread</li>
</ul>
```
Здесь данные жестко закодированы — для простоты. Однако, чаще всего будут использоваться некие данные, обычно представляемые как свойства `PageModel`.

## Передача данных в представления
Есть несколько способов передать данные из [[page-handler|обработчика страницы]] в представление:
- *свойства* `PageModel`;
- `ViewData` — словарь объектов со строковыми ключами для передачи произвольных данных из обработчика страницы в представление. Кроме того, он позволяет передавать данные в файлы **\_layout** — это основная причина использовать `ViewData` вместо свойств `PageModel`;
- `HttpContext` — технически объект `HttpContext` доступен как в обработчике страницы, так и в представлении;
- сервисы `@inject` — можно использовать [[dependency-injection-pattern|внедрение зависимостей]][^1].

Передадим данные через свойства `PageModel`:
```csharp
public class ToDoModel : PageModel
{
	public List<string> Tasks { get; set; }
	public string Title { get;set; }
	
	public void OnGet(int id)
	{
		Title = "Tasks for today";
		Tasks = new List<string>
		{
			"Get fuel",
			"Check oil",
			"Check tyre pressure"
		};
	}
}
```
У представления есть доступ к экземпляру `PageModel` через свойство `Model`, например `<h1>@Model.Title</h1>`.
Иногда возникает необходимость передать данные в макет представления. К примеру — заголовок страницы. Зададим заголовок через `ViewData`: `ViewData["Title"]="Home Page";` и выведем его `<h2>@ViewData["Title"].</h2>`.
Значения во `ViewData` можно задавать как напрямую в словаре, так и помечать строковые свойства атрибутом `[ViewData]`, в этом случае имя свойства будет ключом в словаре.

[^1]: [[ch-10-injecting-services-into-am-ph-views|см. пример]]