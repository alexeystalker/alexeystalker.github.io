---
share: true
tags:
 - NET/MVC
 - NET/Razor
---
# Выбор представления из контроллера MVC
Одним из существенных преимуществ Razor Pages является близкое расположение представления Razor и связанных обработчиков страниц.
Однако, если необходимо использовать контроллеры MVC вместо razor Pages, важно понимать, как выбирается представление, которое необходимо визуализировать.
Метод действия контроллера использует объект `ViewResult`, чтобы указать, что нужно визуализировать представление Razor. Этот объект содержит имя представления и [[view-model|модель представления]].
Вот как выглядит процесс генерации:
![[Pasted image 20220226200245.png]]
Видно что при использовании MVC представление ищется во время выполнения. Для поиска испольуется определеная эвристика на основе указанного во `ViewResult` имени.
Для вызова шаблона представления необходимо создать объект `ViewResult`, однако обычно его не создают явно. Вместо этого используют один из методов `View()` базового класса `Controller`. В простейшем случае можно вызвать метод `View()` без параметров:
```csharp
public class HomeController : Controller
{
	public IActionResult Index()
	{
		return View();
	}
}
```
Этот метод создает объект `ViewResult` без указания имени шаблона. В этом случае путь и имя для поиска формируются на основе имени контроллера и метода действия. Для данного примера, будет искаться файл **Views/Home/Index.cshtml**.
Если, к примеру, указать имя шаблона без расширения, в папке с именем контроллера будет искаться шаблон с соответствующим именем: `View("ListView")` указывает, что в папке **Home** необходимо найти файл **ListView.cshtml**. Также можно указать полный путь к файлу, например `View("Views/global.cshtml")`. Это очень похоже на правила поиска [[ch-7-using-partial-views-to-encapsulate-markups|частичных представлений]].
На картинке — блок-схема, по которой шаблонизатор Razor действует для поиска представления:
![[Pasted image 20220226201634.png]]

Также может быть необходимость, помимо передачи имени шаблона, передать объект модели представления. Этот объект должен соответствовать типу, указанному в директиве представления `@model`, и доступ к нему осуществляется также, как и для Razor Pages — через свойство `Model`.
Вот пример:
```csharp
public class ToDoController : Controller
{
	public IActionResult Index()
	{
		var listViewModel = new ToDoListModel();
		return View(listViewModel);
	}
	
	public IActionResult View(int id)
	{
		var viewModel = new ViewToDoModel();
		return View("ViewToDo", viewModel);
	}
}
```
Далее, после того, как шаблон Razor будет найден, представление визуализируется с использованием синтаксиса Razor. С точки зрения представления Razor нет разницы между MVC и Razor Pages, поэтому макеты, частичные представления и всё, описанное в этой главе, работает точно так же.
