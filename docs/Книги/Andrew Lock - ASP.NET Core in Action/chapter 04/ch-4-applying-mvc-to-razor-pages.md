---
share: true
tags:
 - NET/MVC
 - NET/Razor
 - NET/ASPNETCore/routing
---
# Применение паттерна MVC к Razor Pages
Как уже [[ch-4-mvc-pattern|обсуждалось]], в Razor Pages используется [[mvc-pattern|шаблон MVC]]. Однако, помимо этого, в ASP.NET Core есть *фреймворк* ASP.NET Core MVC. Razor Pages построен поверх него. Впрочем, при желании можно совсем отказаться от Razor Pages и использовать ASP.NET Core MVC непосредственно.
Как мы уже [[ch-3-middleware-pipeline|видели]], конечные точки Razor Page реализуются, используя комбинацию `RoutingMiddleware` и `EndpointMiddleware`.
## Маршрутизация запроса на страницу Razor и создание модели привязки
Первый шаг обработки запроса - маршрутизация к соответствующему [[page-handler|обработчику страницы Razor]]. Снова обратимся к [[ch-4-typical-razor-page|странице списка дел с категориями]]. Пусть мы просматриваем список элементов с категорией Simple, и, соответственно, делаем запрос по пути `/category/Simple`.
[[ch-5-mapping-urls-using-routing|Маршрутизация]] берет заголовки и путь запроса (`/category/Simple`) и сопоставляет их с предварительно зарегистрированным списком паттернов. Каждый из них соответствует пути к одной странице Razor и обработчику страницы.
После выбора обработчика страницы создается [[binding-model|модель привязки]] (если она применима). Эта модель построена на основе входящего запроса, свойств `PageModel`, отмеченных для привязки, и параметров метода, нужных обработчику страницы. В данном случае - простая строка `category`, указанная в [[path|пути]] запроса.
![[Pasted image 20220109161541.png]]
## Выполнение обработчика с использованием модели приложения
Роль обработчика страницы как контроллера в паттерне MVC заключается в координации генерации ответа на запрос, который он обрабатывает. В частности, он должен:
- убедиться в валидности данных из модели привязки;
- вызвать соответствующие действия в модели приложения, используя [[service-aspnetcore|сервисы]];
- выбрать соответствующий ответ для генерации на основе ответа модели приложения.

Здесь под понятием *модель приложения* понимается абстрактная концепция, инкапсулирующая части приложения, не относящиеся к пользовательскому интерфейсу. В частности, в ней содержится [[domain-model|модель предметной области]], сервисы и взаимодействие с БД.
![[Pasted image 20220109162500.png]]
В нашем примере вызывается одна точка модели приложения.
## Генерация HTML-кода с использованием модели представления
Для генерации ответа нам нужно зафиксировать необходимые детали в [[view-model|модели представления]]. В ASP.NET Core MVC *модель представления* - это объект, передающийся в представление Razor для отрисовки. В Razor Pages представление Razor может обращаться к соответсвующему классу `PageModel`, при этом доступ к данным осуществляется через свойства класса.
Важно отметить, что обработчик страницы не контролирует, *какой HTML-код генерируется*. Это решает представление.
![[Pasted image 20220109163522.png]]
## Собираем всё вместе: полный запрос страницы Razor
Вот как объединяются шаги для обработки запроса на отображение списка дел из категории Simple.
![[Pasted image 20220109163847.png]]
Ключевым преимуществом такого процесса является *разделение ответственности*:
- представление отвечает только за генерацию HTML-кода и получение некоторых данных;
- модель приложения отвечает за выполнение необходимой бизнес-логики;
- обработчик страницы (контроллер) отвечает только за проверку входящего запроса и выбор ответа на основе выходных данных модели приложения.