---
share: true
tags:
 - event-sourcing
 - microservice/saga
---
# Реализация оркестраторов повествований с помощью порождения событий
Порождение событий можно использовать и для реализации оркестраторов.
При разработке оркестратора повествований нужно решить три ключевые проблемы:
1. Как будет храниться оркестратор?
2. Как атомарно изменять состояние оркестратора и слать командные сообщения?
3. Как убедиться в том, что оркестратор обрабатывает ответы один раз?
## Сохранение оркестратора при помощи порождения событий
Жизненный цикл оркестратора: сначала создается, затем обновляется в ответ на сообщения участников повествования. Следовательно, нужно только два события: `SagaOrchestratorCreated` и `SagaOrchestratorUpdated`. Эти события содержат данные, необходимые для воссоздания оркестратора.
## Надежная отправка командных сообщений
Для реляционных БД можно вставлять команды в таблицу `MESSAGE` в рамках транзакции. Однако можно воспользоваться способом, который единственно подходит для NoSQL БД.
Главное здесь - сохранить событие `SagaCommandEvent`, представляющее команду, которую нужно отправить.
Команды генерируются в два этапа.
1. Оркестратор генерирует событие `SagaCommandEvent` для каждой команды, которую он хочет отправить. В нем содержатся все данные для отправки команды.
2. Обработчик принимает события `SagaCommandEvent` и отправляет команды в заданный канал

Двухшаговый процесс гарантирует, что команда будет отправлена хотя бы раз. Уникальный ID `SagaCommandEvent` используется в качестве ID командного сообщения - это приведет к тому, что у дубликатов будет один и тот же ID, что позволит определять дубликаты.
## Обработка ответов ровно один раз
Оркестратор сохраняет ID ответа в события, которые он генерирует при обработке ответа, что позволит определять и отклонять дубликаты.