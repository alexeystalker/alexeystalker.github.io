---
share: true
tags:
 - API
---
# Реализация API-шлюза
[[api-gateway-pattern|API-шлюз]] можно реализовать двумя способами.
+ Используя готовый продукт или сервис. Этот вариант практически не требует разработки, но он менее гибок. Так, например, готовые API-шлюзы обычно не поддерживают объединение API.
+ Путём разработки собственного API-шлюза.
## Использование готового API-шлюза
Есть масса вариантов, автор упоминает 3:
- **AWS API Gateway**. Набор ресурсов REST, каждый из которых поддерживает один или несколько методов. В конфигурации нужно указать, какому сервису следует направлять каждую пару "метод-ресурс". В качестве внутреннего сервиса выступает либо AWS Lambda, либо AWS-сервис, либо HTTP-сервис. Также можно сконфигурировать преобразование запросов, используя механизм шаблонов, и аутентификацию. Он НЕ поддерживает объединение API.
- *Kong* - Open Source пакет на основе NGINX
- *Traefik* - Open Source пакет, написанный на Go
## Разработка собственного API-шлюза
При проектировании API-шлюза нужно решить две ключевые проблемы:
- реализовать механизм определения правил маршрутизации
- правильно реализовать HTTP-проксирование, в том числе обработку HTTP-заголовков
Можно воспользоваться готовыми фреймворками, например, для Java это [Zuul](https://github.com/netflix/zuul) от Netflix, или [Spring Cloud Gateway](https://cloud.spring.io/spring-cloud-gateway/reference/html/) - он построен поверх Project Reactor и предоставляет реактивные абстракции.
## Реализация API-шлюза с помощью GraphQL
Пусть мы реализуем ручку `GET /orders/{orderId}` для API-шлюза, которая возвращает подробности о заказе. Эта ручка извлекает данные из разных сервисов, следовательно, нужно использовать шаблон [[api-composition-pattern|объединения API]].
Еще одна трудность состоит в том, что разным клиентам нужны немного разные данные. Можно либо позволить клиенту указывать, какая информация ему нужна, либо воспользоваться [[bff-pattern|шаблоном BFF]]. Однако это довольно хлопотно.
Обратим внимание на графовый API-фреймворк GraphQL. Суть заключается в том, что API сервера имеет структуру *графа*
![[Pasted image 20211017201556.png]]
Графовая структура (схема) задает набор *узлов*(типов), имеющих *свойства*(поля) и связи с другими узлами. Чтобы извлечь данные, клиент выполняет запрос, который описывает необходимую информацию в виде узлов графа, их свойств и связей. В итоге клиент получает необходимую информацию за одно обращение к шлюзу.
Архитектура, основанная на GraphQL, имеет следующие ключевые аспекты:
- *Схема GraphQL* описывает модель серверных данных и запросы, которые она поддерживает.
- *Функции сопоставления* накладывают элементы схемы на различные внутренние сервисы
- *Прокси-классы* обращаются к сервисам приложения

