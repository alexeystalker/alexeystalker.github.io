---
share: true
tags:
 - SQL/injection
---
# Предотвращение атак с использованием внедрения SQL-кода (SQL injection) с помощью EF Core и параметризации
Атаки путём внедрения SQL-кода (SQL injections) — одна из самых серьезных угроз для приложения.
Пусть в [[ch-12-sample-application|приложении с рецептами]] есть форма поиска рецепта по названию. Если мы будем собирать SQL-запрос для такого поиска вручную, то откроем путь для подобной уязвимости.
```csharp
public IList<User> FindRecipe(string search)
{
	return _context.Recipes
		.FromSqlRaw("SELECT * FROM Recipes WHERE Name = '" + search + "'")
		.ToList();
}
```
Здесь пользовательский ввод `search` непосредственно включается в SQL-запрос. Создавая вредоносный ввод, злоумышленник может потенциально выполнять любые операции над БД. Например, запрос в поиске
```sql
'; DROP TABLE Recipes; --
```
приведёт к посторению запроса
```sql
SELECT * FROM Recipes WHERE Name = ''; DROP TABLE Recipes; --'
```
Выполнение такого запроса приведёт, как уже понятно, к удалению всей таблицы рецептов.
Даже если правильно настроить полномочия для БД, злоумышленники, вероятно, смогут прочитать все данные из базы.
Самый простой способ избежать этого — не создавать SQL-запросы вручную через конкатенацию строк. Даже если необходимо написать SQL-запрос вручную, можно использовать параметризацию запросов, например:
```csharp
public IList<User> FindRecipe(string search)
{
	return _context.Recipes
		.FromSqlRaw("SELECT * FROM Recipes WHERE Name = '{0}'", search)
		.ToList();
}
```
Параметризованные запросы неуязвимы для атак с SQL injection. Если же используется EF Core (или другие ORM-инструменты) и её [[ch-12-quering-data-from-and-saving-data-to-db|стандартные LINQ-запросы]] — в этом случае тоже всё хорошо. EF Core автоматически создаст параметризованные запросы.
> [!Note] Примечание
> Мы говорим о атаке SQL injection, но NoSQL и документоориентированные БД также могут быть подвержены аналогичным атакам. Никогда нельзя создавать запросы, просто конкатенируя строки.

