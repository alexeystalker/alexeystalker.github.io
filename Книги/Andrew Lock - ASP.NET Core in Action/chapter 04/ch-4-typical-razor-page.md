---
share: true
tags:
 - NET/Razor
---
# Изучение типичной страницы Razor
В [[ch-2-razor-pages-response|главе 2]] мы рассмотрели очень простую страницу Razor, не имевшую дополнительной, помимо отображения связанного представления, логики. Однако, чаще всего страницы Razor будут содержать некую логику, загружать данные из БД или использовать формы для ввода информации.
Поэтому рассмотрим страницу посложнее. Возмем ее из гипотетического приложения со списком дел (To do List) — эта страница отображает все дела одной категории.
Вот часть кода из PageModel этой страницы:
```csharp
public class CategoryModel : PageModel
{
	private readonly ToDoService _service;
	public CategoryModel(ToDoService service)
	{
		_service = service;
	}
	
	public ActionResult OnGet(string category)
	{
		Items = _service.GetItemsForCategory(category);
		return Page();
	}
	
	public List<ToDoListModel> Items { get; set; }
}
```
Как мы видим, по сравнению с примером из главы 2, появилось много нового:
- обработчик `OnGet` принимает параметр `category`, который заполняется при помощи [[binding-model|привязки модели (Model Binding)]][^1];  
- обработчик использует значение `category`, чтобы получить данные из БД при помощи объекта `ToDoService`, ссылка на который внедряется через конструктор;
- обработчик возвращает `Page()` в конце метода, чтобы указать, что связанное представление должно быть отрисовано. По соглашению, если обработчик страницы имеет тип возвращаемого значения `void`, после завершения метода представление отрисовывается;
- представление Razor имеет доступ к экземпляру CategoryModel, поэтому может получить доступ к свойству Items.

Паттерн взаимодействий, в итоге, таков: обработчик страницы получает входные данные от пользователя (`category`), обращается к БД (через `ToDoService`) и возвращает данные (через свойство `Items`) представлению Razor. Это соответствует шаблону проектирования *Модель–представление–контроллер (Model–View–Controller, MVC)*.

[^1]: [[ch-6-models-in-razor-pages-and-mvc|Подробнее]]
